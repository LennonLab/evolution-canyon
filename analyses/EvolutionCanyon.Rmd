---
title: "Evolution Canyon"
author: "Mario E. Muscarella, Kenneth J. Locey, & Jay T. Lennon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
   - \usepackage{array}
   - \usepackage{graphics}
output:
  pdf_document:
  fig_caption: true
---

Dormancy, dispersal, and environmental filtering at "Evolution Canyon"

Brief Description:


# Initial Setup
```{r results='hide', message=FALSE}
rm(list=ls())
getwd()
setwd("~/GitHub/evolution-canyon/analyses")

# Import Required Packages
library("png")
library("grid")
library("vegan")
library("labdsv")

# Import Scripts
source("../bin/ec.dbRDA.R")
source("../bin/MothurTools.R")

# Common Functions
sem <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
```


# Figure 1: Conceptual model
theory and predictions of how environmental filtering and dormancy influence 
community assembly (with dispersal being implicit and more or less high) 
```{r fig.width=2, fig.height=4,echo=FALSE,fig.cap="Figure 1: Conceptual Model"}
img <- readPNG("../figures/ConceptualModel_new.png")
grid.raster(img)
```

# Figure 2: Photo of EC and simulation of EC-like landscape
```{r fig.width=2, fig.height=4,echo=FALSE,fig.cap="Figure 1: Conceptual Model"}
img1 <- readPNG("../figures/ECLandscape.png")
img2 <- readPNG("../figures/BIDELandscape.png")
grid.newpage()
grid.raster(img1, x=0.5, y = 0.75, width=0.5)
grid.raster(img2, x = 0.5, y = 0.35, width=0.5)
```

# BIDE Model Ordinations
Ordination of simulated data capturing processes/scenarios described in Fig. 1. 
```{r}
# Close Plot Device
dev.off()
graphics.off()

# Define Analysis
ec.dbRDA.sim <- function(shared = " ", level = "0.03", design = " "){

  # Example Data
  #   shared     = "../microbide/SbyS/Condition1.txt"
  #   cutoff     = "0.03"
  #   design     = "../data/simmy.design.txt"

  source("../bin/DiversityFunctions.r")
  require("vegan")

  # Import Site by OTU Matrix
  ec_data.sim <- read.otu(shared, "0.03")
  design <- read.delim(design, header=T, row.names=1)

  # Remove OTUs with less than two observations
  ec_data_red <- ec_data.sim[,colSums(ec_data.sim) >= 2]

  # Create factors for model
  slope <- design$slope       # factor 1
  molecule <- design$molecule # factor 2
  paired <- design$paired     # pairs
  site <- design$site         # sites
  station <- design$station

  # Create Y matrix with factor 1 and 2
  slope.molecule <- data.frame(cbind(as.character(slope),
    as.character(molecule)))

  # create unique treat ID vector
  slope.molecule.concat <- do.call(paste, c(slope.molecule[c("X1", "X2")],
    sep = ""))
  pair.station <- c(rep(seq(1:9), each=2), rep(seq(1:5), each=2),
    rep(seq(1:10), each=2), rep(seq(1:9), each=2))

  # Create a vector of molecules by station
  station.molecule.concat <- paste(station, molecule, sep = "")

  # Rarefied
  floor(min(rowSums(ec_data_red)))
  ec_data_red <- rrarefy(ec_data_red, 0.9 * min(rowSums(ec_data_red)))
  
  # Calculate Presense Absence
  dataPA <- (ec_data_red > 0)*1
  
  # Calculating Relative Abundance
  dataREL <- ec_data_red
  for(i in 1:nrow(ec_data_red)){
    dataREL[i,] = ec_data_red[i,]/sum(ec_data_red[i,])
  }
  
  # Log Transform Relative Abundance
  dataREL.l <- suppressWarnings(decostand(dataREL,method="log"))

  # Chord Transformation
  dataREL.c <- suppressWarnings(decostand(dataREL, method="normalize"))

  # Hellinger Transformation
  dataREL.h <- suppressWarnings(decostand(dataREL, method="hellinger"))

  # PCoA
  PCoA <- cmdscale(vegdist(dataREL.l, method = "bray"), k = 2, eig = T)
  
  # Distance Based Redundancy Analysis
  dbRDA <- capscale(dataREL.l ~ slope + molecule , distance="bray")

#   head(summary(dbRDA))
#   anova(dbRDA, by="terms", permu=999)
#   varpart(dataREL,  ~ slope, ~ molecule)

  # Percent Variance Explained Using PCoA (Axis 1,2,3)
  #explainvar1 <- round(dbRDA$CCA$eig[1]/sum(dbRDA$CCA$eig, dbRDA$CA$eig)*100,2)
  #explainvar2 <- round(dbRDA$CCA$eig[2]/sum(dbRDA$CCA$eig, dbRDA$CA$eig)*100,2)
  explainvar1 <- round(PCoA$eig[1]/sum(PCoA$eig) * 100, 2)
  explainvar2 <- round(PCoA$eig[2]/sum(PCoA$eig) * 100, 2)

  #RDA <- as.data.frame(dbRDA$CCA$wa)
  RDA <- as.data.frame(scores(dbRDA, display = c("wa"), scaling = "sites"))
  RDA$molecule <- design$molecule
  RDA$slope <- design$slope
  RDA$labs <- slope.molecule.concat
  
  # Permanova
  adonis.out <- adonis(dataREL.l ~ RDA$molecule * RDA$slope)
  
  # RDA Stats
  rda.stats <- anova(dbRDA, by="terms", permu=999)
  var.part <- varpart(vegdist(dataREL.l, method = "bray"),  ~ slope, ~ molecule)
  
  # PCoA
  ec.bc <- vegdist(dataREL.l, method = "bray")
  ec.pcoa <- cmdscale(ec.bc, k = 3, eig = T)

  RDA.out <- list("RDA" = RDA, "PCoA" = PCoA,
                  "explainvar1" = explainvar1,
                  "explainvar2" = explainvar2, 
                  "Permanova" = adonis.out,
                  "dbRDA" = rda.stats, "Var_Part" = var.part)

  return(RDA.out)

}

# Run Function with BIDE output
#dir <- "../microbide/SbyS/supp/lgp=0.9202_im=0.9921_dispkernel=0.013/"
dir <- "../microbide/SbyS/"
input <- list.files(dir, "*.txt")
input <- input[c(1, 2, 3, 4)]

# Create Blank Output
dbRDA.output <- list()
permanova.output <- list()

# Run PCoA On All Samples
for (i in 1:length(input)){
  dbRDA.output[[input[i]]] = ec.dbRDA.sim(shared = paste(dir, input[i], sep=""), 
                                             level = "0.03", 
                                             design = "../data/simmy.design.txt")
}
```

## Figure 3
```{r}
png(filename = "../figures/BIDE_Ordination.png", 
    width = 1600, height = 1200, res = 96 * 2)

# Plot Parameters
par(mfrow=c(1,1), mar=c(0.5,0.5,0,0), oma=c(6, 6, 1, 1))
layout(matrix(c(5, 5, 1:4), 3, 2, byrow=T), heights=c(1, rep(5, 2)))

labs <- c("A", "B", "C", "D", "E", "F")
x.lab <- c(F, F, T, T)
y.lab <- c(T, F, T, F)

# Plot Each
for (p in 1:length(dbRDA.output)){
  RDA <- dbRDA.output[[p]]$RDA
  PCoA <- dbRDA.output[[p]]$PCoA
  explainvar1 <- dbRDA.output[[p]]$explainvar1
  explainvar2 <- dbRDA.output[[p]]$explainvar2
  print(explainvar1)
  print(explainvar2)

  x.dim <- c(-0.09, 0.09)
  y.dim <- c(-0.08, 0.08)

  # Initiate Plot
  plot(PCoA$points[, 1], PCoA$points[, 2], xlab = "", ylab="",
    xlim=x.dim,ylim= y.dim, pch=16, cex=2.0, type="n",xaxt="n",
    yaxt="n", cex.lab=1.5, cex.axis=1.2)

  axis(side=1, las=1, label=x.lab[p], lwd.ticks = 2, cex.axis = 1.25)
  axis(side=2, las=0, label=y.lab[p], lwd.ticks = 2, cex.axis = 1.25)
  axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2) 
  axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2)
  axis(side = 3, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2)     
  axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2)
  clip(-0.08, 0.1, -0.064, 0.1)
  abline(h=0, lty="dotted")
  abline(v=0, lty="dotted")
  clip(-0.1, 0.1, -0.1, 0.1)
  mol.shape <- rep(NA, dim(RDA)[1])
    for (i in 1:length(mol.shape)){
      if (RDA$molecule[i] == "DNA"){mol.shape[i] = 21}
      else {mol.shape[i] = 22}
      }
  slope.color <- rep(NA, dim(RDA)[1])
    for (i in 1:length(slope.color)){
      if (RDA$slope[i] == levels(RDA$slope)[1]) {slope.color[i] = "wheat3"}
      else {slope.color[i] = "green3"}
    }
  ran.ord <- sample(1:length(slope.color), length(slope.color), replace = F)
  points(PCoA$points[, 1][ran.ord], PCoA$points[, 2][ran.ord], 
         pch=mol.shape[ran.ord], 
         cex=2.0, col="black", bg=slope.color[ran.ord], lwd=2)
  box(lwd=2)
  
  text(x = -0.09, y = 0.075, labs[p], cex = 1.5)
  text(x = 0, y = -0.075, adj = 0.5, 
       labels = paste("PCoA 1 = ", explainvar1, "%", sep = ""), cex = 1.25)
  text(x = -0.09, y = 0, adj = 0.5, srt=90,
       labels = paste("PCoA 2 = ", explainvar2, "%", sep = ""), cex = 1.25)
}
  
mtext("Axis 1", side = 1, cex = 1.5, outer=T, line = 3)
mtext("Axis 2", side = 2, cex = 1.5, outer=T, line = 3) 
  
# Legend
par(mar=c(0, 0, 0, 0))
plot.new()
legend("center", c(paste("All; ",levels(RDA$slope)[1]," Slope", sep=""),
      paste("All; ",levels(RDA$slope)[2]," Slope", sep=""),
      paste("Active; ",levels(RDA$slope)[1]," Slope", sep=""),
      paste("Active; ",levels(RDA$slope)[2]," Slope", sep="")),
      pt.lwd=2, col="black", pt.bg=c("wheat3", "green3", "wheat3",
      "green3"), pch=c(21,21,22,22), bty='n', ncol=4, cex=1.5, pt.cex=2)  

# Close Plot Device
dev.off()
graphics.off()
#```

## Show Plot
#```{r}
img <- readPNG("../figures/BIDE_Ordination.png")
grid.raster(img)
```

## Multivariate Summary of BIDE Simulations
A general discussion that the simulations agreed with theory outlined in Fig. 1. 
Will reference ordinations and PCoA. 
Discussed Table 1 having summary data from the PERMANOVA results.

```{r}
dbRDA.output[[1]]$dbRDA
dbRDA.output[[1]]$Var_Part
plot(dbRDA.output[[1]]$Var_Part, Xnames = c("Slope", "Molecule"))

dbRDA.output[[2]]$Var_Part
dbRDA.output[[3]]$Var_Part

dbRDA.output[[4]]$dbRDA
dbRDA.output[[4]]$Var_Part
plot(dbRDA.output[[4]]$Var_Part)
```

# Emperical Data Ordinations
Ordination of empirical data consistent with the view that non-random entrance and exiting from dormancy on top of environmental filtering influence community assembly
```{r}
# Define Inputs
shared <- "../data/EC.bac.final.shared"
design.in <- "../data/design.txt"
level  <-  "0.03"

# Import Shared File
ec_data <- read.otu(shared, "0.03")

# Note: owing to amplification issues, we only sequenced 76 of 80 samples.
# The four samples not included are C-1E-R, EC-2G-R, EC-2J-R, EC-6I-D
dim(ec_data)
counts <- count.groups(otu.matrix = ec_data)
low.coverage <- counts[which(counts < 50000)]

# Remove low coverage samples 
ec_data2 <- ec_data[-c(which(rownames(ec_data) %in% c(names(low.coverage)))), ]

# Remove problematic samples (EC_2A_D, EC_2A_R, EC_2C_R, EC_2D_R)
#ec_data.tmp <- ec_data2[-c(9,20:21,24:27,32,37,74),]
ec_data3 <- ec_data2[-c(which(rownames(ec_data2) %in% 
                     c("EC_2A_D", "EC_2A_R","EC_2C_R", "EC_2D_R"))), ]

# Remove OTUs with less than two observations across samples
ec_data_red <- ec_data3[,which(colSums(ec_data3) >= 5)]

# Rarefied
floor(min(rowSums(ec_data_red)))
# ec_data_red <- rrarefy(ec_data_red, 0.9 * min(rowSums(ec_data_red)))

# Import Design
design <- read.delim(design.in, header=T, row.names=1)

# Match OTU matrix and design
design_red <- design[which(rownames(design) %in% rownames(ec_data_red)),]

# Create factors for model
slope <- design_red$slope # factor 1
molecule <- design_red$molecule # factor 2
paired <- design_red$paired_across_slope
site <- design_red$site
station <- design_red$station
slope.molecule <- data.frame(cbind(as.character(slope),
                  as.character(molecule))) # Y matrix with factor 1 and 2
slope.molecule.concat <- do.call(paste, 
                                 c(slope.molecule[c("X1", "X2")],
                                   sep = "")) # create unique treat ID vector

# Create a vector of molecules by station
station.molecule.concat <- paste(station, molecule, sep = "")
pair.station <- c(rep(seq(1:9), each=2), rep(seq(1:5), each=2), 
                  rep(seq(1:10), each=2), rep(seq(1:9), each=2))

# To include "questionable" data uncomment the following
# pair.station <- c(rep(seq(1:9), each=2), rep(seq(1:8), each=2),
#    rep(seq(1:10), each=10), rep(seq(1:9), each=2))

# Define OTU Matrix
otu.matrix <- ec_data_red

# Calculate Presense Absence
dataPA <- (otu.matrix > 0)*1

# Calculating Relative Abundance
dataREL <- otu.matrix
for(i in 1:nrow(otu.matrix)){
  dataREL[i,] = otu.matrix[i,]/sum(otu.matrix[i,])
  }

# Log Transform Relative Abundance
dataREL.l <- decostand(dataREL,method="log")

# Chord Transformation
dataChord <- decostand(ec_data_red, method="normalize")

# Hellinger Transformation
dataHell <- decostand(ec_data_red, method="hellinger")

# Create Distance Matrix with Bray Curtis
samplePA.dist <- vegdist(dataREL.l,method="bray")
sampleREL.dist <- vegdist(dataREL.l,method="bray")

# PCoA
ec.bc <- vegdist(dataREL.l, method = "bray")
ec.pcoa <- cmdscale(ec.bc, k = 3, eig = T)

# Percent Variance Explained Using PCoA (Axis 1,2,3)
explainvar1 <- round(ec.pcoa$eig[1]/sum(ec.pcoa$eig)*100,2)
explainvar2 <- round(ec.pcoa$eig[2]/sum(ec.pcoa$eig)*100,2)

PCoA <- as.data.frame(scores(ec.pcoa, display = "sites"))
PCoA$molecule <- molecule
PCoA$slope <- slope
PCoA$station <- station
PCoA$labs <- slope.molecule.concat

PCoA.out <- list("PCoA" = PCoA,
                "explainvar1" = explainvar1,
                "explainvar2" = explainvar2)
```

## Figure 4
```{r}
# Plot
png(filename = "../figures/EC_Ordination.png", 
    width = 1000, height = 1000, res = 96 * 2)

# Plot Parameters
par(mfrow=c(1,1), mar=c(0.5,0.5,0,0), oma=c(1, 1, 1, 1))
layout(matrix(c(1, 2), 2, 1, byrow=T), heights=c(4, 1))

par(mar=c(4,4,0,0))

x.lab <- c(T)
y.lab <- c(T)

# Plot
PCoA <- PCoA.out$PCoA
explainvar1 <- PCoA.out$explainvar1
explainvar2 <- PCoA.out$explainvar2

x.dim <- c(-0.3, 0.3)
y.dim <- c(-0.25, 0.2)

# Initiate Plot
plot(PCoA$Dim1, PCoA$Dim2, xlab = "", ylab="",
     xlim=x.dim,ylim= y.dim, pch=16, cex=2.0, type="n",xaxt="n",
     yaxt="n", cex.lab=1.5, cex.axis=1.2)

axis(side=1, las=1, label=T, lwd.ticks = 2)
axis(side=2, las=1, label=T, lwd.ticks = 2)
axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1) 
axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
axis(side = 3, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)     
axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
abline(h=0, lty="dotted")
abline(v=0, lty="dotted")
mol.shape <- rep(NA, dim(PCoA)[1])
  for (i in 1:length(mol.shape)){
    if (PCoA$molecule[i] == "DNA"){mol.shape[i] = 21}
    else {mol.shape[i] = 22}
  }

slope.color <- rep(NA, dim(PCoA)[1])
  for (i in 1:length(slope.color)){
    if (PCoA$slope[i] == levels(PCoA$slope)[1]) {slope.color[i] = "wheat3"}
    else {slope.color[i] = "green3"}
  }


points(PCoA$Dim1, PCoA$Dim2, pch=mol.shape, cex=1.5, 
       col="black", bg=slope.color, lwd=2)
text(PCoA$Dim1 * 1.2, PCoA$Dim2 * 1.2, labels = PCoA$station)
ordiellipse(cbind(PCoA$Dim1, PCoA$Dim2), RDA$labs, kind="sd", conf=0.95,
            lwd=2, lty=3, draw = "lines", col = "black", label=FALSE)
box(lwd=2)
  
mtext(paste("PCoA 1 (", explainvar1, "%)", sep = ""), side = 1, cex = 1.5, outer=F, line = 3)
mtext(paste("PCoA 2 (", explainvar2, "%)", sep = ""), side = 2, cex = 1.5, outer=F, line = 3) 
  
# Legend
par(mar=c(0,4,0,0))
plot.new()
legend("center", c(paste("All; ",levels(PCoA$slope)[1]," Slope", sep=""),
      paste("All; ",levels(PCoA$slope)[2]," Slope", sep=""),
     paste("Active; ",levels(PCoA$slope)[1]," Slope", sep=""),
   paste("Active; ",levels(PCoA$slope)[2]," Slope", sep="")),
   pt.lwd=2, col="black", pt.bg=c("wheat3", "green3", "wheat3",
   "green3"), pch=c(21,21,22,22), bty='n', ncol=2, cex=1, pt.cex=1.2)  

# Close Plot Device
dev.off()
graphics.off()
#```

## Show Plot
#```{r}
img <- readPNG("../figures/EC_Ordination.png")
grid.raster(img)
```

## Multivariate Summary
```{r}
# Distance Based Redundancy Analysis
dbRDA_pair <- dbrda(dataREL.l ~ slope * molecule + Condition(paired), distance="bray")
dbRDA <- dbrda(dataREL.l ~ slope * molecule, distance="bray")

head(summary(dbRDA))
anova(dbRDA, by="terms", permu=999)
anova(dbRDA_pair, by = "terms", permu = 999)
varpart(dataREL,  ~ slope, ~ molecule)

#RDA <- as.data.frame(dbRDA$CCA$wa)
RDA <- as.data.frame(scores(dbRDA, display = c("wa"), scaling = "sites"))
RDA$molecule <- molecule
RDA$slope <- slope
RDA$labs <- slope.molecule.concat


# PERMANOVA
Adonis.b <- adonis(dataREL.l ~ design_red$molecule * design_red$slope)
Adonis.b
```

## Within Site Diversity
```{r}
shared <- "../data/EC.bac.final.shared"
design.in <- "../data/design.txt"
level  <-  "0.03"

# Run PCoA On Emperical Data

ec_data <- read.otu(shared, "0.03")

# Note: owing to amplification issues, we only sequenced 76 of 80 samples.
# The four samples not included are C-1E-R, EC-2G-R, EC-2J-R, EC-6I-D
dim(ec_data)
counts <- count.groups(otu.matrix = ec_data)
low.coverage <- counts[which(counts < 50000)]

# Remove low coverage samples 
ec_data2 <- ec_data[-c(which(rownames(ec_data) %in% c(names(low.coverage)))), ]

# Remove problematic samples (EC_2A_D, EC_2A_R, EC_2C_R, EC_2D_R)
#ec_data.tmp <- ec_data2[-c(9,20:21,24:27,32,37,74),]
ec_data3 <- ec_data2[-c(which(rownames(ec_data2) %in% 
                     c("EC_2A_D", "EC_2A_R","EC_2C_R", "EC_2D_R"))), ]

rownames(ec_data3)

# Remove OTUs with less than two observations across samples
ec_data_red <- ec_data3[,which(colSums(ec_data3) >= 10)]

EC.OTU <- ec_data_red

# Import Design
design <- read.delim(design.in, header=T, row.names=1)

# Match OTU matrix and design
design_red <- design[which(rownames(design) %in% rownames(ec_data_red)),]

EC.design <- design_red

# Samples by molecules
DNA <- rownames(EC.design[which(EC.design$molecule == "DNA"), ])
RNA <- rownames(EC.design[which(EC.design$molecule == "RNA"), ])

par(mfrow = c(2, 1), mar = c(2, 2, 2, 1), oma = c(4, 3, 1, 1))
hist(rowSums(EC.OTU[which(rownames(EC.OTU) %in% DNA), ]),  las = 1, ylim = c(0, 18),
     main = "DNA", xlab = "", ylab = "", breaks = seq(0, 250000, by = 25000))
mtext(side = 2, "Sites", line = 3, cex = 1.5)
hist((rowSums(EC.OTU[which(rownames(EC.OTU) %in% RNA), ])),  las = 1, ylim = c(0, 18),
     main = "RNA",xlab = "", ylab = "", breaks = seq(0, 250000, by = 25000))
mtext(side = 1, "Counts", line = 3, cex = 1.5)
mtext(side = 2, "Sites", line = 3, cex = 1.5)

# Calculate Richness and Evenness with Iterative Resampling
S.iter <- richness.iter(EC.OTU, min(rowSums(EC.OTU) * 0.9), 100)
E.iter <- evenness.iter(EC.OTU, min(rowSums(EC.OTU) * 0.9), 100)
write.csv(S.iter, file = "../data/ec.richness.txt", quote = F)
write.csv(E.iter, file = "../data/ec.evenness.txt", quote = F)
S.iter <- read.csv("../data/ec.richness.txt", row.names = 1)
E.iter <- read.csv("../data/ec.evenness.txt", row.names = 1)

all.equal(row.names(S.iter), row.names(EC.design))
all.equal(row.names(E.iter), row.names(EC.design))

# Anova w/ Posthoc
S.aov <- Anova(lm(S.iter$S ~ slope*molecule), type = "II")
# Anova w/ Posthoc
E.aov <- Anova(lm(E.iter$E ~ slope*molecule), type = "II")
S.tukey <- agricolae::HSD.test(lm(S.iter$S ~ slope*molecule), 
                               trt = c("slope", "molecule"))
E.tukey <- agricolae::HSD.test(lm(E.iter$E ~ slope*molecule), 
                               trt = c("slope", "molecule"))

```

## Alpha Diveristy Plot
```{r}
png(filename = "../figures/EC_Alpha.png", 
    width = 1600, height = 1000, res = 96 * 2)

par(mfrow = c(1, 1), mar = c(4, 4, 2, 2), oma = c(2, 2, 0, 0))
layout(matrix(c(1,2), ncol = 2, byrow=T))

S.bp <- boxplot(S.iter$S ~ slope.molecule.concat, lwd = 1.5, 
        col = c("wheat3", "wheat3", "green3", "green3"),
        xlab = "", ylab = "", ylim = c(3000, 5150), axes = F)
axis(side=1, las=1, at = c(1, 2, 3, 4), 
     labels=c("All", "Active", "All", "Active"), lwd.ticks = 2)
axis(side=1, las=1, at = c(1.5, 3.5), tick = F, line = 2,
     labels=c("African", "European"), font = 2)
axis(side=2, las=1, label=T, lwd.ticks = 2)
axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1) 
axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
mtext("Species Richness", side = 2, cex = 1.5, outer=F, line = 3.5) 
text(x = c(1,2,3,4), y = S.bp$stats[5,] + 70, labels = c("a", "a", "b", "b"))
box(lwd=2)

E.bp <- boxplot(E.iter$E ~ slope.molecule.concat, lwd = 1.5, 
        col = c("wheat3", "wheat3", "green3", "green3"),
        xlab = "", ylab = "", ylim = c(0.02, 0.08), axes = F)
axis(side=1, las=1, at = c(1, 2, 3, 4), 
     labels=c("All", "Active", "All", "Active"), lwd.ticks = 2)
axis(side=1, las=1, at = c(1.5, 3.5), tick = F, line = 2,
     labels=c("African", "European"), font = 2)
axis(side=2, las=1, label=T, lwd.ticks = 2, at = c(0.02, 0.04, 0.06, 0.08))
axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1) 
axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1,
     at = c(0.02, 0.04, 0.06, 0.08))
axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1, 
     at = c(0.02, 0.04, 0.06, 0.08))
mtext("Species Evenness", side = 2, cex = 1.5, outer=F, line = 3.5) 
text(x = c(1,2,3,4), y = E.bp$stats[5,] + 0.002, labels = c("b", "a", "c", "b"))

box(lwd=2) 
        
# Close Plot Device
dev.off()
graphics.off()

## Show Plot
img <- readPNG("../figures/EC_Alpha.png")
grid.raster(img)
```

# Indicator Taxa
```{r}
# Import Taxonomy
ec.tax <- read.tax(taxonomy = "../data/EC.bac.final.0.03.taxonomy", 
                   format = "rdp")

# Run Indicator Species Analysis Using Slope/Molecule
ec.indicators <- indval(dataREL, slope.molecule.concat)

# Pull Out Indicator Data for Significant Indicators
gr <- ec.indicators$maxcls[ec.indicators$pval<=0.05]
iv <- ec.indicators$indcls[ec.indicators$pval<=0.05]
pv <- ec.indicators$pval[ec.indicators$pval<=0.05]
fr <- apply(dataREL, 2, sum)[ec.indicators$pval<=0.05]

# Combine Data
indvalsummary <- data.frame(group=gr, indval=iv, pvalue=pv, freq=fr)
indvalsummary <- indvalsummary[order(indvalsummary$group,
                                     -indvalsummary$indval),]

# Subset for OTUs with freq > 0.01
indvalsummary2 <- indvalsummary[which(indvalsummary$freq > 0.05), ]

# Get Taxonomic Information
indvalsummary2.names <- rownames(indvalsummary2)
indvalsummary2.tax <- ec.tax[which(ec.tax$OTU %in% indvalsummary2.names ), ]
indvalsummary2.tax <- indvalsummary2.tax[match(indvalsummary2.names, indvalsummary2.tax$OTU),]
all.equal(as.character(indvalsummary2.tax$OTU), indvalsummary2.names)

# Combine Data
indvalsummary3 <- cbind(indvalsummary2, indvalsummary2.tax)

# Remove Unclassified
indvalsummary3 <- indvalsummary3[-c(which(indvalsummary3$Phylum == "Bacteria_unclassified")), ]

# Seperate Into Groups
Ind_AFDNA <- indvalsummary3[which(indvalsummary3$group == 1), ]
Ind_AFRNA <- indvalsummary3[which(indvalsummary3$group == 2), ]
Ind_EUDNA <- indvalsummary3[which(indvalsummary3$group == 3), ]
Ind_EURNA <- indvalsummary3[which(indvalsummary3$group == 4), ]

table(Ind_AFDNA$Class)
table(Ind_EUDNA$Class)
table(Ind_AFRNA$Family)
table(Ind_EURNA$Order)

dim(Ind_AFRNA)
dim(Ind_EURNA)

# Just RNA 
ind_RNA <- rbind(Ind_AFRNA, Ind_EURNA)

```

## Phylogenetic Diversity Notes

A multi-fasta file was generated with representative sequences for each OTU.
Representatives were picked based on the most abundant unique sequence in each OTU.
[FastTree](http://www.microbesonline.org/fasttree/) was used to construct a phylogenetic tree.
Note: This must be done before performing the following analyses.
The following parameters were used:

```{sh, eval = F}
Note: eDNA.bac.final.0.03.rep.fasta is larger than the github limits. Please obtain the file from SDA or DC2, (contact Lennon or Muscarella)

Note: The names must be renamed so that they match the OTU names:

> python2 ../bin/rename.py 

> FastTree -gtr -nt -gamma -fastest EC.bac.final.0.03.rep.rename.fasta > EC.bac.rename.tree

Output:
ML-NNI round 13: LogLk = -1936292.923 NNIs 2543 max delta 14.99 Time 2566.20 (final)delta 14.991)   
Optimize all lengths: LogLk = -1936204.904 Time 2627.30
Gamma(20) LogLk = -1937091.865 alpha = 0.990 rescaling lengths by 1.405   
Total time: 2982.76 seconds Unique: 51830/51830 Bad splits: 84/51827 Worst delta-LogLk 7.510
```



## Indicator Figure
```{r}

library("ape");library("phytools")
ec.tree <- ape::read.tree("../data/EC.bac.rename.tree")

ec.ind.tree <- drop.tip(ec.tree, setdiff(ec.tree$tip.label, ind_RNA$OTU))
#ec.ind.tree <- midpoint.root(ec.ind.tree)

ind_RNA2 <- ind_RNA[match(ec.ind.tree$tip.label, ind_RNA$OTU), ]
write.csv(ind_RNA2, file = "../data/indicators.txt", quote = F)

ec.ind.tree$tip.label
ind_RNA2$OTU

tip.col <- ind_RNA2$group
tip.col[which(tip.col == "2")] <- "wheat3"
tip.col[which(tip.col == "4")] <- "green3"

par(mar = c(1, 1, 1, 1), oma = c(0, 0, 0, 0))
plot(ec.ind.tree, type = "phylogram", use.edge.length = F, tip.color = tip.col)
# black = AF, red = EU

# ec.ind.tree$node.label <- ec.ind.tree$edge[, 1]

library("adephylo");library("phylobase")
x <- phylobase::phylo4d(ec.ind.tree, tip.data = ind_RNA2$group, merge.data = F, check.node.labels = "drop")
table.phylo4d(x, treetype = "phylo", symbol = "colors", show.node = FALSE,
              cex.label = 0.8, scale = FALSE, use.edge.length = FALSE,
              edge.color = "black", edge.width = 1.5, box = FALSE,
              pch = 15, cex.symbol = 2, legend = F, col = c("wheat3", "green3"), 
              ratio.tree = 0.8, center = FALSE,
              )

library(ggtree)

all.equal(ec.ind.tree$tip.label, as.character(ind_RNA2$OTU))
groupInfo <- split(ec.ind.tree$tip.label, ind_RNA2$Order)
ec.ind.tree2 <- groupOTU(ec.ind.tree, groupInfo, group_name = "Order")
levels(attributes(ec.ind.tree2)$Phylym) <- names(groupInfo)


ggtree(ec.ind.tree2, ladderize = T, aes(color =Order)) + 
  geom_tippoint(color=tip.col, size = 1) + 
  geom_tiplab(size=2) + 
  geom_text2(aes(subset=!isTip, label=node), hjust=-0.3) + 
  geom_text2(aes(subset=isTip, label=Order), hjust=-1, size = 3)




ggtree(IMGtree, aes(color = Domain), layout="rectangular") + 
       geom_text(aes(label = node), show.legend = FALSE,
       hjust=-0.1, vjust = -0.5, size = 2) + 
  theme(legend.position="top", 
        legend.key = element_rect(colour = NA)) + 
  geom_point2(aes(subset=(node == (archaea + 
             length(IMGtree$tip.label)))),
             size=3, shape=18, fill = "gray80", 
             colour=ggplotColours(n = 3)[1]) + 
  scale_color_manual(values=c(ggplotColours(n = 3)[2:3])) 

```

```{r}
ec.tax2 <- ec.tax[which(ec.tax$OTU %in% colnames(dataREL)), ]
all.equal(colnames(dataREL), as.character(ec.tax2$OTU))
dataREL.tax <- cbind(t(dataREL), ec.tax2)
head(dataREL.tax)

table(dataREL.tax$Class)

```






# Generalist and Specialists
```{r}
# Spatial Generalits: Found in majority of Sites
# otu.matrix, dataPA
# Import Taxonomy
ec.tax <- read.tax(taxonomy = "../data/EC.bac.final.0.03.taxonomy", 
                   format = "silva")


dataPA[1:5, 1:5]

dim(dataPA); dim(design_red)
dataPA.active <- dataPA[which(design_red$molecule == "RNA"), ]
dataPA.all    <- dataPA[which(design_red$molecule == "DNA"), ]
ec.gens <- names(which(colSums(dataPA.active) == dim(dataPA.active)[1]))

ec.gens.tax <- ec.tax[which(ec.tax$OTU %in% ec.gens), ]

ec.gens.rel <- dataREL[, which(colnames(dataREL) %in% ec.gens)]
rowSums(ec.gens.rel)

ec.gens.rel[1:5, 1:5]

# AF Specialists
dataPA.aa <- dataPA[which(design_red$molecule == "RNA" & 
                            design_red$slope == "AF"), ]
dim(dataPA.aa)
ec.aa.gens <- names(which(colSums(dataPA.aa) == dim(dataPA.aa)[1]))


# EU Specialists
dataPA.ae <- dataPA[which(design_red$molecule == "RNA" & 
                            design_red$slope == "EU"), ]
dim(dataPA.ae)
ec.ae.gens <- names(which(colSums(dataPA.ae) == dim(dataPA.ae)[1]))

ec.aa.spec <- setdiff(ec.aa.gens, ec.ae.gens)

```


