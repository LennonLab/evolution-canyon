---
title: "Evolution Canyon"
author: "Mario E. Muscarella, Kenneth J. Locey, & Jay T. Lennon"
date: "`r format(Sys.time(), '%d %B, %Y')`"
header-includes:
   - \usepackage{array}
   - \usepackage{graphics}
output:
  pdf_document:
  fig_caption: true
---

Dormancy, dispersal, and environmental filtering at "Evolution Canyon"

Brief Description:


# Initial Setup
```{r results='hide', message=FALSE}
rm(list=ls())
getwd()
setwd("~/GitHub/evolution-canyon/analyses")

# Import Required Packages
require("png")
require("grid")
require("vegan")

# Import Scripts
source("../bin/ec.dbRDA.R")
source("../bin/MothurTools.R")

# Common Functions
sem <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}
```


# Figure 1: Conceptual model
theory and predictions of how environmental filtering and dormancy influence 
community assembly (with dispersal being implicit and more or less high) 
```{r fig.width=2, fig.height=4,echo=FALSE,fig.cap="Figure 1: Conceptual Model"}
img <- readPNG("../figures/ConceptualModel_new.png")
grid.raster(img)
```

# Figure 2: Photo of EC and simulation of EC-like landscape
```{r fig.width=2, fig.height=4,echo=FALSE,fig.cap="Figure 1: Conceptual Model"}
img1 <- readPNG("../figures/ECLandscape.png")
img2 <- readPNG("../figures/BIDELandscape.png")
grid.newpage()
grid.raster(img1, x=0.5, y = 0.75, width=0.5)
grid.raster(img2, x = 0.5, y = 0.35, width=0.5)
```

# BIDE Model Ordinations
Ordination of simulated data capturing processes/scenarios described in Fig. 1. 
```{r}
# Close Plot Device
dev.off()
graphics.off()

# Define Analysis
ec.dbRDA.sim <- function(shared = " ", level = "0.03", design = " "){

  # Example Data
  #   shared     = "../microbide/SbyS/Condition1.txt"
  #   cutoff     = "0.03"
  #   design     = "../data/simmy.design.txt"

  source("../bin/DiversityFunctions.r")
  require("vegan")

  # Import Site by OTU Matrix
  ec_data.sim <- read.otu(shared, "0.03")
  design <- read.delim(design, header=T, row.names=1)

  # Remove OTUs with less than two observations
  ec_data_red <- ec_data.sim[,colSums(ec_data.sim) >= 2]

  # Create factors for model
  slope <- design$slope       # factor 1
  molecule <- design$molecule # factor 2
  paired <- design$paired     # pairs
  site <- design$site         # sites
  station <- design$station

  # Create Y matrix with factor 1 and 2
  slope.molecule <- data.frame(cbind(as.character(slope),
    as.character(molecule)))

  # create unique treat ID vector
  slope.molecule.concat <- do.call(paste, c(slope.molecule[c("X1", "X2")],
    sep = ""))
  pair.station <- c(rep(seq(1:9), each=2), rep(seq(1:5), each=2),
    rep(seq(1:10), each=2), rep(seq(1:9), each=2))

  # Create a vector of molecules by station
  station.molecule.concat <- paste(station, molecule, sep = "")

  # Rarefied
  floor(min(rowSums(ec_data_red)))
  ec_data_red <- rrarefy(ec_data_red, 0.9 * min(rowSums(ec_data_red)))
  
  # Calculate Presense Absence
  dataPA <- (ec_data_red > 0)*1
  
  # Calculating Relative Abundance
  dataREL <- ec_data_red
  for(i in 1:nrow(ec_data_red)){
    dataREL[i,] = ec_data_red[i,]/sum(ec_data_red[i,])
  }
  
  # Log Transform Relative Abundance
  dataREL.l <- suppressWarnings(decostand(dataREL,method="log"))

  # Chord Transformation
  dataREL.c <- suppressWarnings(decostand(dataREL, method="normalize"))

  # Hellinger Transformation
  dataREL.h <- suppressWarnings(decostand(dataREL, method="hellinger"))

  # PCoA
  PCoA <- cmdscale(vegdist(dataREL.l, method = "bray"), k = 2, eig = T)
  
  # Distance Based Redundancy Analysis
  dbRDA <- capscale(dataREL.l ~ slope + molecule , distance="bray")

#   head(summary(dbRDA))
#   anova(dbRDA, by="terms", permu=999)
#   varpart(dataREL,  ~ slope, ~ molecule)

  # Percent Variance Explained Using PCoA (Axis 1,2,3)
  #explainvar1 <- round(dbRDA$CCA$eig[1]/sum(dbRDA$CCA$eig, dbRDA$CA$eig)*100,2)
  #explainvar2 <- round(dbRDA$CCA$eig[2]/sum(dbRDA$CCA$eig, dbRDA$CA$eig)*100,2)
  explainvar1 <- round(PCoA$eig[1]/sum(PCoA$eig) * 100, 2)
  explainvar2 <- round(PCoA$eig[2]/sum(PCoA$eig) * 100, 2)

  #RDA <- as.data.frame(dbRDA$CCA$wa)
  RDA <- as.data.frame(scores(dbRDA, display = c("wa"), scaling = "sites"))
  RDA$molecule <- design$molecule
  RDA$slope <- design$slope
  RDA$labs <- slope.molecule.concat
  
  # Permanova
  adonis.out <- adonis(dataREL.l ~ RDA$molecule * RDA$slope)
  
  # RDA Stats
  rda.stats <- anova(dbRDA, by="terms", permu=999)
  var.part <- varpart(vegdist(dataREL.l, method = "bray"),  ~ slope, ~ molecule)
  
  # PCoA
  ec.bc <- vegdist(dataREL.l, method = "bray")
  ec.pcoa <- cmdscale(ec.bc, k = 3, eig = T)

  RDA.out <- list("RDA" = RDA, "PCoA" = PCoA,
                  "explainvar1" = explainvar1,
                  "explainvar2" = explainvar2, 
                  "Permanova" = adonis.out,
                  "dbRDA" = rda.stats, "Var_Part" = var.part)

  return(RDA.out)

}


dir <- "../microbide/SbyS/supp/lgp=0.9202_im=0.9921_dispkernel=0.013/"
dir <- "../microbide/SbyS/"

input <- list.files(dir, "*.txt")
input <- input[c(1, 2, 3, 4)]

input
test <- read.delim(paste(dir, input[1], sep = ""), header = T)
rowSums(as.matrix(test[ 1, -c(1:3)]))

# Create Blank Output
dbRDA.output <- list()
permanova.output <- list()

# Run PCoA On All Samples
for (i in 1:length(input)){
  dbRDA.output[[input[i]]] = ec.dbRDA.sim(shared = paste(dir, input[i], sep=""), 
                                             level = "0.03", 
                                             design = "../data/simmy.design.txt")
}
```

## Figure 3
```{r}
png(filename = "../figures/BIDE_Ordination.png", 
    width = 1600, height = 1200, res = 96 * 2)

# Plot Parameters
par(mfrow=c(1,1), mar=c(0.5,0.5,0,0), oma=c(6, 6, 1, 1))
layout(matrix(c(5, 5, 1:4), 3, 2, byrow=T), heights=c(1, rep(5, 2)))

labs <- c("A", "B", "C", "D", "E", "F")
x.lab <- c(F, F, T, T)
y.lab <- c(T, F, T, F)

# Plot Each
for (p in 1:length(dbRDA.output)){
  RDA <- dbRDA.output[[p]]$RDA
  PCoA <- dbRDA.output[[p]]$PCoA
  explainvar1 <- dbRDA.output[[p]]$explainvar1
  explainvar2 <- dbRDA.output[[p]]$explainvar2
  print(explainvar1)
  print(explainvar2)

  x.dim <- c(-0.09, 0.09)
  y.dim <- c(-0.08, 0.08)

  # Initiate Plot
  plot(PCoA$points[, 1], PCoA$points[, 2], xlab = "", ylab="",
    xlim=x.dim,ylim= y.dim, pch=16, cex=2.0, type="n",xaxt="n",
    yaxt="n", cex.lab=1.5, cex.axis=1.2)

  axis(side=1, las=1, label=x.lab[p], lwd.ticks = 2, cex.axis = 1.25)
  axis(side=2, las=0, label=y.lab[p], lwd.ticks = 2, cex.axis = 1.25)
  axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2) 
  axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2)
  axis(side = 3, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2)     
  axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2)
  clip(-0.08, 0.1, -0.064, 0.1)
  abline(h=0, lty="dotted")
  abline(v=0, lty="dotted")
  clip(-0.1, 0.1, -0.1, 0.1)
  mol.shape <- rep(NA, dim(RDA)[1])
    for (i in 1:length(mol.shape)){
      if (RDA$molecule[i] == "DNA"){mol.shape[i] = 21}
      else {mol.shape[i] = 22}
      }
  slope.color <- rep(NA, dim(RDA)[1])
    for (i in 1:length(slope.color)){
      if (RDA$slope[i] == levels(RDA$slope)[1]) {slope.color[i] = "wheat3"}
      else {slope.color[i] = "green3"}
    }
  ran.ord <- sample(1:length(slope.color), length(slope.color), replace = F)
  points(PCoA$points[, 1][ran.ord], PCoA$points[, 2][ran.ord], 
         pch=mol.shape[ran.ord], 
         cex=2.0, col="black", bg=slope.color[ran.ord], lwd=2)
  box(lwd=2)
  
  text(x = -0.09, y = 0.075, labs[p], cex = 1.5)
  text(x = 0, y = -0.075, adj = 0.5, 
       labels = paste("PCoA 1 = ", explainvar1, "%", sep = ""), cex = 1.25)
  text(x = -0.09, y = 0, adj = 0.5, srt=90,
       labels = paste("PCoA 2 = ", explainvar2, "%", sep = ""), cex = 1.25)
}
  
mtext("Axis 1", side = 1, cex = 1.5, outer=T, line = 3)
mtext("Axis 2", side = 2, cex = 1.5, outer=T, line = 3) 
  
# Legend
par(mar=c(0, 0, 0, 0))
plot.new()
legend("center", c(paste("All; ",levels(RDA$slope)[1]," Slope", sep=""),
      paste("All; ",levels(RDA$slope)[2]," Slope", sep=""),
      paste("Active; ",levels(RDA$slope)[1]," Slope", sep=""),
      paste("Active; ",levels(RDA$slope)[2]," Slope", sep="")),
      pt.lwd=2, col="black", pt.bg=c("wheat3", "green3", "wheat3",
      "green3"), pch=c(21,21,22,22), bty='n', ncol=4, cex=1.5, pt.cex=2)  

# Close Plot Device
dev.off()
graphics.off()
#```

## Show Plot
#```{r}
img <- readPNG("../figures/BIDE_Ordination.png")
grid.raster(img)
```

## Multivariate Summary of BIDE Simulations
A general discussion that the simulations agreed with theory outlined in Fig. 1. 
Will reference ordinations and PCoA. 
Discussed Table 1 having summary data from the PERMANOVA results.

```{r}
dbRDA.output[[1]]$dbRDA
dbRDA.output[[1]]$Var_Part
plot(dbRDA.output[[1]]$Var_Part, Xnames = c("Slope", "Molecule"))

dbRDA.output[[2]]$Var_Part
dbRDA.output[[3]]$Var_Part

dbRDA.output[[4]]$dbRDA
dbRDA.output[[4]]$Var_Part
plot(dbRDA.output[[4]]$Var_Part)
```

# Emperical Data Ordinations
Ordination of empirical data consistent with the view that non-random entrance and exiting from dormancy on top of environmental filtering influence community assembly

```{r}
shared <- "../data/EC.bac.final.shared"
design.in <- "../data/design.txt"
level  <-  "0.03"

# Run PCoA On Emperical Data

ec_data <- read.otu(shared, "0.03")

# Note: owing to amplification issues, we only sequenced 76 of 80 samples.
# The four samples not included are C-1E-R, EC-2G-R, EC-2J-R, EC-6I-D
dim(ec_data)
counts <- count.groups(otu.matrix = ec_data)
low.coverage <- counts[which(counts < 50000)]

# Remove low coverage samples 
ec_data2 <- ec_data[-c(which(rownames(ec_data) %in% c(names(low.coverage)))), ]

# Remove problematic samples (EC_2A_D, EC_2A_R, EC_2C_R, EC_2D_R)
#ec_data.tmp <- ec_data2[-c(9,20:21,24:27,32,37,74),]
ec_data3 <- ec_data2[-c(which(rownames(ec_data2) %in% 
                     c("EC_2A_D", "EC_2A_R","EC_2C_R", "EC_2D_R"))), ]

rownames(ec_data3)

# Remove OTUs with less than two observations across samples
ec_data_red <- ec_data3[,which(colSums(ec_data3) >= 5)]

# Rarefied
floor(min(rowSums(ec_data_red)))
# ec_data_red <- rrarefy(ec_data_red, 0.9 * min(rowSums(ec_data_red)))

# Import Design
design <- read.delim(design.in, header=T, row.names=1)

# Match OTU matrix and design
design_red <- design[which(rownames(design) %in% rownames(ec_data_red)),]

# Create factors for model
slope <- design_red$slope # factor 1
molecule <- design_red$molecule # factor 2
paired <- design_red$paired_across_slope
site <- design_red$site
station <- design_red$station
slope.molecule <- data.frame(cbind(as.character(slope),
                  as.character(molecule))) # Y matrix with factor 1 and 2

slope.molecule.concat <- do.call(paste, 
                                 c(slope.molecule[c("X1", "X2")],
                                   sep = "")) # create unique treat ID vector

# Create a vector of molecules by station
station.molecule.concat <- paste(station, molecule, sep = "")


pair.station <- c(rep(seq(1:9), each=2), rep(seq(1:5), each=2), 
                  rep(seq(1:10), each=2), rep(seq(1:9), each=2))

# To include "questionable" data uncomment the following
# pair.station <- c(rep(seq(1:9), each=2), rep(seq(1:8), each=2),
#    rep(seq(1:10), each=10), rep(seq(1:9), each=2))

# Define OTU Matrix
otu.matrix <- ec_data_red

# Calculate Presense Absence
dataPA <- (otu.matrix > 0)*1

all.equal(row.names(ec_data_red), row.names(design_red))
boxplot(rowSums(dataPA) ~ slope.molecule.concat)

# Calculating Relative Abundance
dataREL <- otu.matrix
for(i in 1:nrow(otu.matrix)){
  dataREL[i,] = otu.matrix[i,]/sum(otu.matrix[i,])
  }

# Log Transform Relative Abundance
dataREL.l <- decostand(dataREL,method="log")

# Chord Transformation
dataChord <- decostand(ec_data_red, method="normalize")

# Hellinger Transformation
dataHell <- decostand(ec_data_red, method="hellinger")

# Create Distance Matrix with bray (deafault), manhattan, euclidean, canberra, bray, kulczynski, jaccard, gower, altGower, morisita, horn, mountford, raup, binomial, or chao. Most should be part of vegan, but possilbly 'labdsv' or 'BiodiversityR' packages

samplePA.dist <- vegdist(dataREL.l,method="bray")
sampleREL.dist <- vegdist(dataREL.l,method="bray")

# PCoA
ec.bc <- vegdist(dataREL.l, method = "bray")
ec.pcoa <- cmdscale(ec.bc, k = 3, eig = T)

# Percent Variance Explained Using PCoA (Axis 1,2,3)
explainvar1 <- round(ec.pcoa$eig[1]/sum(ec.pcoa$eig)*100,2)
explainvar2 <- round(ec.pcoa$eig[2]/sum(ec.pcoa$eig)*100,2)

PCoA <- as.data.frame(scores(ec.pcoa, display = "sites"))
PCoA$molecule <- molecule
PCoA$slope <- slope
PCoA$station <- station
PCoA$labs <- slope.molecule.concat

PCoA.out <- list("PCoA" = PCoA,
                "explainvar1" = explainvar1,
                "explainvar2" = explainvar2)
```

## Figure 4
```{r}
# Plot
png(filename = "../figures/EC_Ordination.png", 
    width = 1000, height = 1000, res = 96 * 2)

# Plot Parameters
par(mfrow=c(1,1), mar=c(0.5,0.5,0,0), oma=c(1, 1, 1, 1))
layout(matrix(c(1, 2), 2, 1, byrow=T), heights=c(4, 1))

par(mar=c(4,4,0,0))

x.lab <- c(T)
y.lab <- c(T)

# Plot
PCoA <- PCoA.out$PCoA
explainvar1 <- PCoA.out$explainvar1
explainvar2 <- PCoA.out$explainvar2

x.dim <- c(-0.3, 0.3)
y.dim <- c(-0.25, 0.2)

# Initiate Plot
plot(PCoA$Dim1, PCoA$Dim2, xlab = "", ylab="",
     xlim=x.dim,ylim= y.dim, pch=16, cex=2.0, type="n",xaxt="n",
     yaxt="n", cex.lab=1.5, cex.axis=1.2)

axis(side=1, las=1, label=T, lwd.ticks = 2)
axis(side=2, las=1, label=T, lwd.ticks = 2)
axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1) 
axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
axis(side = 3, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)     
axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
abline(h=0, lty="dotted")
abline(v=0, lty="dotted")
mol.shape <- rep(NA, dim(PCoA)[1])
  for (i in 1:length(mol.shape)){
    if (PCoA$molecule[i] == "DNA"){mol.shape[i] = 21}
    else {mol.shape[i] = 22}
  }

slope.color <- rep(NA, dim(PCoA)[1])
  for (i in 1:length(slope.color)){
    if (PCoA$slope[i] == levels(PCoA$slope)[1]) {slope.color[i] = "wheat3"}
    else {slope.color[i] = "green3"}
  }


points(PCoA$Dim1, PCoA$Dim2, pch=mol.shape, cex=1.5, 
       col="black", bg=slope.color, lwd=2)
text(PCoA$Dim1 * 1.2, PCoA$Dim2 * 1.2, labels = PCoA$station)
ordiellipse(cbind(PCoA$Dim1, PCoA$Dim2), RDA$labs, kind="sd", conf=0.95,
            lwd=2, lty=3, draw = "lines", col = "black", label=FALSE)
box(lwd=2)
  
mtext(paste("PCoA 1 (", explainvar1, "%)", sep = ""), side = 1, cex = 1.5, outer=F, line = 3)
mtext(paste("PCoA 2 (", explainvar2, "%)", sep = ""), side = 2, cex = 1.5, outer=F, line = 3) 
  
# Legend
par(mar=c(0,4,0,0))
plot.new()
legend("center", c(paste("All; ",levels(PCoA$slope)[1]," Slope", sep=""),
      paste("All; ",levels(PCoA$slope)[2]," Slope", sep=""),
     paste("Active; ",levels(PCoA$slope)[1]," Slope", sep=""),
   paste("Active; ",levels(PCoA$slope)[2]," Slope", sep="")),
   pt.lwd=2, col="black", pt.bg=c("wheat3", "green3", "wheat3",
   "green3"), pch=c(21,21,22,22), bty='n', ncol=2, cex=1, pt.cex=1.2)  

# Close Plot Device
dev.off()
graphics.off()
#```

## Show Plot
#```{r}
img <- readPNG("../figures/EC_Ordination.png")
grid.raster(img)
```

## Multivariate Summary
```{r}

# Distance Based Redundancy Analysis
dbRDA_pair <- dbrda(dataREL.l ~ slope * molecule + Condition(paired), distance="bray")
dbRDA <- dbrda(dataREL.l ~ slope * molecule, distance="bray")

head(summary(dbRDA))
anova(dbRDA, by="terms", permu=999)
anova(dbRDA_pair, by = "terms", permu = 999)
varpart(dataREL,  ~ slope, ~ molecule)

# Percent Variance Explained Using PCoA (Axis 1,2,3)
explainvar1 <- round(dbRDA$CCA$eig[1]/sum(dbRDA$CCA$eig, dbRDA$CA$eig)*100,2)
explainvar2 <- round(dbRDA$CCA$eig[2]/sum(dbRDA$CCA$eig, dbRDA$CA$eig)*100,2)

#RDA <- as.data.frame(dbRDA$CCA$wa)
RDA <- as.data.frame(scores(dbRDA, display = c("wa"), scaling = "sites"))
RDA$molecule <- molecule
RDA$slope <- slope
RDA$labs <- slope.molecule.concat

RDA.out <- list("RDA" = RDA,
                "explainvar1" = explainvar1,
                "explainvar2" = explainvar2)




# Match OTU matrix and design
design_red <- design[which(rownames(design) %in% rownames(ec_data_red)),]


# Relative Abundances
sbysREL <- ec_data_red
for(j in 1:nrow(ec_data_red)){
  sbysREL[j,] = ec_data_red[j,]/sum(ec_data_red[j,])
}
  
# Log Transformation
sbysREL.log <- decostand(sbysREL, method="log")
Adonis.b <- adonis(sbysREL.log ~ design_red$molecule * design_red$slope)
Adonis.b
```


## Within Site Diversity
```{r}
shared <- "../data/EC.bac.final.shared"
design.in <- "../data/design.txt"
level  <-  "0.03"

# Run PCoA On Emperical Data

ec_data <- read.otu(shared, "0.03")

# Note: owing to amplification issues, we only sequenced 76 of 80 samples.
# The four samples not included are C-1E-R, EC-2G-R, EC-2J-R, EC-6I-D
dim(ec_data)
counts <- count.groups(otu.matrix = ec_data)
low.coverage <- counts[which(counts < 50000)]

# Remove low coverage samples 
ec_data2 <- ec_data[-c(which(rownames(ec_data) %in% c(names(low.coverage)))), ]

# Remove problematic samples (EC_2A_D, EC_2A_R, EC_2C_R, EC_2D_R)
#ec_data.tmp <- ec_data2[-c(9,20:21,24:27,32,37,74),]
ec_data3 <- ec_data2[-c(which(rownames(ec_data2) %in% 
                     c("EC_2A_D", "EC_2A_R","EC_2C_R", "EC_2D_R"))), ]

rownames(ec_data3)

# Remove OTUs with less than two observations across samples
ec_data_red <- ec_data3[,which(colSums(ec_data3) >= 10)]

EC.OTU <- ec_data_red

# Import Design
design <- read.delim(design.in, header=T, row.names=1)

# Match OTU matrix and design
design_red <- design[which(rownames(design) %in% rownames(ec_data_red)),]

EC.design <- design_red

# Samples by molecules
DNA <- rownames(EC.design[which(EC.design$molecule == "DNA"), ])
RNA <- rownames(EC.design[which(EC.design$molecule == "RNA"), ])

par(mfrow = c(2, 1), mar = c(2, 2, 2, 1), oma = c(4, 3, 1, 1))
hist(rowSums(EC.OTU[which(rownames(EC.OTU) %in% DNA), ]),  las = 1, ylim = c(0, 18),
     main = "DNA", xlab = "", ylab = "", breaks = seq(0, 250000, by = 25000))
mtext(side = 2, "Sites", line = 3, cex = 1.5)
hist((rowSums(EC.OTU[which(rownames(EC.OTU) %in% RNA), ])),  las = 1, ylim = c(0, 18),
     main = "RNA",xlab = "", ylab = "", breaks = seq(0, 250000, by = 25000))
mtext(side = 1, "Counts", line = 3, cex = 1.5)
mtext(side = 2, "Sites", line = 3, cex = 1.5)


# Function for Calculating Species Richness w/ Resampling
richness.iter <- function(otu.matrix  = " ", 
                          sample.size = " ", 
                          iters       = " "){
  rich.matrix <- matrix(NA, dim(otu.matrix)[1], iters)
  rownames(rich.matrix) <- rownames(otu.matrix)
  for (i in 1:iters){
    temp.matrix <- rrarefy(otu.matrix, sample.size)
    rich.matrix[,i] <- rowSums((temp.matrix>0)*1)
  }
  rich.mean <- apply(rich.matrix, 1, mean)
  rich.se <- apply(rich.matrix, 1, sem)
  return(data.frame(S = rich.mean, S_se = rich.se))
}

# Function for Simpsons Evenness w/ Resampling
evenness.iter <- function(otu.matrix  = " ", 
                          sample.size = " ", 
                          iters       = " "){
  simp_even <- function(SAD = " "){
  SAD <- subset(SAD, SAD > 0)
  S <- length(SAD); N <- sum(SAD); X <- rep(NA, S)
  for (i in 1:S){
    X[i] <- (SAD[i]*(SAD[i] - 1)) / (N * (N - 1))
    }
  D <- sum(X); e_d <- (1/D)/S
  return(e_d)
  }
  even.matrix <- matrix(NA, dim(otu.matrix)[1], iters)
  rownames(even.matrix) <- rownames(otu.matrix)
  for (i in 1:iters){
    temp.matrix <- rrarefy(otu.matrix, sample.size)
    even.matrix[,i] <- apply(temp.matrix, 1, simp_even)
    }
  even.mean <- apply(even.matrix, 1, mean)
  even.se <- apply(even.matrix, 1, sem)
  return(data.frame(E = even.mean, E_se = even.se))
}

#S.iter <- richness.iter(EC.OTU, min(rowSums(EC.OTU) * 0.9), 100)
#E.iter <- evenness.iter(EC.OTU, min(rowSums(EC.OTU) * 0.9), 100)
#write.csv(S.iter, file = "../data/ec.richness.txt", quote = F)
#write.csv(E.iter, file = "../data/ec.evenness.txt", quote = F)
S.iter <- read.csv("../data/ec.richness.txt", row.names = 1)
E.iter <- read.csv("../data/ec.evenness.txt", row.names = 1)

all.equal(row.names(S.iter), row.names(EC.design))
all.equal(row.names(E.iter), row.names(EC.design))

# Anova w/ Posthoc
S.aov <- Anova(lm(S.iter$S ~ slope*molecule), type = "II")
# Anova w/ Posthoc
E.aov <- Anova(lm(E.iter$E ~ slope*molecule), type = "II")
S.tukey <- agricolae::HSD.test(lm(S.iter$S ~ slope*molecule), 
                               trt = c("slope", "molecule"))
E.tukey <- agricolae::HSD.test(lm(E.iter$E ~ slope*molecule), 
                               trt = c("slope", "molecule"))

```

```{r}

png(filename = "../figures/EC_Alpha.png", 
    width = 1600, height = 1000, res = 96 * 2)

par(mfrow = c(1, 1), mar = c(4, 4, 2, 2), oma = c(2, 2, 0, 0))
layout(matrix(c(1,2), ncol = 2, byrow=T))

S.bp <- boxplot(S.iter$S ~ slope.molecule.concat, lwd = 1.5, 
        col = c("wheat3", "wheat3", "green3", "green3"),
        xlab = "", ylab = "", ylim = c(3000, 5000), axes = F)
axis(side=1, las=1, at = c(1, 2, 3, 4), 
     labels=c("All", "Active", "All", "Active"), lwd.ticks = 2)
axis(side=1, las=1, at = c(1.5, 3.5), tick = F, line = 2,
     labels=c("African", "European"), font = 2)
axis(side=2, las=1, label=T, lwd.ticks = 2)
axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1) 
axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1)
mtext("Species Richness", side = 2, cex = 1.5, outer=F, line = 3.5) 
text(x = c(1,2,3,4), y = S.bp$stats[5,] + 70, labels = c("a", "a", "b", "b"))
box(lwd=2)

E.bp <- boxplot(E.iter$E ~ slope.molecule.concat, lwd = 1.5, 
        col = c("wheat3", "wheat3", "green3", "green3"),
        xlab = "", ylab = "", ylim = c(0.02, 0.08), axes = F)
axis(side=1, las=1, at = c(1, 2, 3, 4), 
     labels=c("All", "Active", "All", "Active"), lwd.ticks = 2)
axis(side=1, las=1, at = c(1.5, 3.5), tick = F, line = 2,
     labels=c("African", "European"), font = 2)
axis(side=2, las=1, label=T, lwd.ticks = 2, at = c(0.02, 0.04, 0.06, 0.08))
axis(side = 1, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1) 
axis(side = 2, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1,
     at = c(0.02, 0.04, 0.06, 0.08))
axis(side = 4, lwd.ticks = 2, tck=0.01, labels = F,  cex.axis = 2, las = 1, 
     at = c(0.02, 0.04, 0.06, 0.08))
mtext("Species Evenness", side = 2, cex = 1.5, outer=F, line = 3.5) 
text(x = c(1,2,3,4), y = E.bp$stats[5,] + 0.002, labels = c("b", "a", "c", "b"))

box(lwd=2) 
        
      

# Close Plot Device
dev.off()
graphics.off()

## Show Plot
img <- readPNG("../figures/EC_Alpha.png")
grid.raster(img)
```


# Generalist and Specialists
```{r}
# Spatial Generalits: Found in majority of Sites
# otu.matrix, dataPA
# Import Taxonomy
ec.tax <- read.tax(taxonomy = "../data/EC.bac.final.0.03.taxonomy", 
                   format = "silva")


dataPA[1:5, 1:5]

dim(dataPA); dim(design_red)
dataPA.active <- dataPA[which(design_red$molecule == "RNA"), ]
dataPA.all    <- dataPA[which(design_red$molecule == "DNA"), ]
ec.gens <- names(which(colSums(dataPA.active) == dim(dataPA.active)[1]))

ec.gens.tax <- ec.tax[which(ec.tax$OTU %in% ec.gens), ]

ec.gens.rel <- dataREL[, which(colnames(dataREL) %in% ec.gens)]
rowSums(ec.gens.rel)

ec.gens.rel[1:5, 1:5]

# AF Specialists
dataPA.aa <- dataPA[which(design_red$molecule == "RNA" & 
                            design_red$slope == "AF"), ]
dim(dataPA.aa)
ec.aa.gens <- names(which(colSums(dataPA.aa) == dim(dataPA.aa)[1]))


# EU Specialists
dataPA.ae <- dataPA[which(design_red$molecule == "RNA" & 
                            design_red$slope == "EU"), ]
dim(dataPA.ae)
ec.ae.gens <- names(which(colSums(dataPA.ae) == dim(dataPA.ae)[1]))

ec.aa.spec <- setdiff(ec.aa.gens, ec.ae.gens)

```

# Indicator Taxa
```{r}

library("labdsv")

ec.indicators <- indval(dataREL, slope.molecule.concat)
summary(ec.indicators, p = 0.05, type = "long", digits = 3, sort = T)


gr <- ec.indicators$maxcls[ec.indicators$pval<=0.05]
iv <- ec.indicators$indcls[ec.indicators$pval<=0.05]
pv <- ec.indicators$pval[ec.indicators$pval<=0.05]
fr <- apply(dataREL, 2, sum)[ec.indicators$pval<=0.05]
indvalsummary <- data.frame(group=gr, indval=iv, pvalue=pv, freq=fr)
indvalsummary <- indvalsummary[order(indvalsummary$group,
                                     -indvalsummary$indval),]
indvalsummary2 <- indvalsummary[which(indvalsummary$freq > 0.01), ]
indvalsummary2.names <- rownames(indvalsummary2)

indvalsummary2.tax <- ec.tax[which(ec.tax$OTU %in% indvalsummary2.names ), ]

```






